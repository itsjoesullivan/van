<!doctype html>
<html>
  <head>
    <link href='https://fonts.googleapis.com/css?family=Vollkorn:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
    <style>
      html, body {
        font-family: "baskerville-urw", serif;
      }
      h1,
      h2,
      h3,
      h4 {
        font-family: "le-monde-journal-std-2",sans-serif;
      }
      code,
      pre {
        font-family: "inconsolata", monospace;
      }
      .container {
        max-width: 600px;
        margin: auto;
        margin-top: 2em;
        margin-bottom: 2em;
      }
      h1 {
        text-align: center;
      }
      p {
        text-indent: 4em;
        font-size: 1.1em;
        line-height: 1.8em;
      }
      .byline { text-align: right; }
    </style>
    <meta name="viewport" content="width=device-width">
  <title>Digital Ocean Documentation-Generated API Library</title>
  </head>
  <body>
<div class="container">
<h1>Digital Ocean Documentation-Generated API Library</h1>
<p class="byline"><a href="/van">Joe Sullivan</a></p>
<p>
Digging into the <a href="https://developers.digitalocean.com/documentation/v2/">Digital Ocean API documentation</a>, I thought it was darn good documentation. In fact, it seemed so darn good that I wondered if it would be possible to generate a library for the API by scraping the documentation. It turns out that <a href="https://github.com/itsjoesullivan/digital-ocean-api-v2">it is</a>, and what follows is part description of the process of making it, and part other thoughts that came up in the process.
</p>
<h2>Overview</h2>
<p>
The approach that I landed on has two pieces: convert the HTML of the documentation into JSON describing the API, then write an NPM package to read that JSON and expose each action to the consumer.
</p>
<h2>HTML to JSON</h2>
<p>
Each API action consists of, at most, a path, a method, and a list of properties to be sent in the body. Below is one of the more complex operations (transfer an image from one data center to another).
<pre>{
  "images": [{
    "name": "transferImage",
    "path": "/v2/images/$IMAGE_ID/actions",
    "method": "POST",
    "requiredResourceIdCount": 1,
    "requiredProperties": [
      {
        "name": "type",
        "type": "string",
        "required": true
      },
      {
        "name": "region",
        "type": "string",
        "required": true
      }
    ],
    "staticProperties": {
      "type": "transfer"
    }
  }]
}</pre>
<ul>
  <li>Individual actions are under categories ("transferImage" is under the "images" category).</li>
  <li>The path can contain one or more ID fields. See <code>$IMAGE_ID</code> above.</li>
  <li>The body may need certain properties' values to be set (e.g. <code>{type: "transfer"}</code> is what conveys that this is a transfer operation). The <code>staticProperties</code> property holds these values.</li>
  <li>Finally, certain parameters may be required to perform the request.</li>
</ul>
</p>
<p>
I'm not sure it's necessary to go into the actual process of parsing the HTML. I used <a href="https://github.com/cheeriojs/cheerio">cheerio</a>, and all the data required above is present in the documentation. The actual parser script is <a href="https://github.com/itsjoesullivan/parsed-digital-ocean-api-documentation/blob/parser/parser.js">here</a>.
</p>
<h2>JSON to .js</h2>
<p>
The code that bootstraps the library currently stands at 65 lines of code, comments included, so it suffices to say that once you have the JSON, most of the work is done. The process that the package follows, though, is to feed the JSON into a <a href="https://github.com/itsjoesullivan/digital-ocean-api-v2/blob/master/lib/factory.js">factory</a> (which is surprisingly simple) that converts objects into functions, yielding an object like:
<pre>api = {
  droplets: {
    createNewDroplet: [Function],
    retrieveExistingDropletById: [Function]
    ...
  },
  images: {
    listAllImages: [Function],
    retrieveExistingImageById: [Function]
    ...
  },
  ...
}</pre>
Each function returns a promise via <code>request-promise</code>.
</p>
<h2>From library to CLI</h2>
<p>
That's more or less the process. To use the API from the command line, there is <a href="https://github.com/itsjoesullivan/digital-ocean-wrench">digital-ocean-wrench</a> ( <code>npm install -g dow</code> ). It uses a <a href="https://github.com/itsjoesullivan/digital-ocean-wrench/blob/master/lib/method-map.json">map</a> to convert:
<br />
<pre>    <code>dow floating-ip create --region=nyc2</code></pre>
<pre>        to</pre>
<pre>    <code>api.floatingIPActions.createNewFloatingIPReservedToRegion({ region: "nyc2" })</code></pre>
</p>
<h2>More...</h2>
<p>Working on this, I noticed several issues in the documentation: <a href="https://developers.digitalocean.com/documentation/v2/#delete-a-floating-ips">one pluralization error</a>, <a href="https://developers.digitalocean.com/documentation/v2/#list-neighbors-for-a-droplet">one instance</a> where a <code>PATH</code> is described unusually, and <a href="https://developers.digitalocean.com/documentation/v2/#get-user-information">one action</a> that is simply not described at all. This in spite of the fact that this is great documentation. This brings up the point that API documentation doesn't usually meet the same quality standards as the code it describes, so it should be used with caution. Releases of <a href="https://github.com/itsjoesullivan/parsed-digital-ocean-api-documentation">parsed-digital-ocean-api-documentation</a> will need to be carefully reviewed.
</p>
<p>
This experience raises the question: should documentation be good enough to generate a library from? It seems like a pretty good characteristic of documentation. API libraries often skip the methods that aren't useful to the author/s. An automated process, on the other hand, makes it just as easy to generate a complete library as an incomplete one.
</p>
<p>
How well can this method of library generation travel? A useful next step would be to survey other popular APIs and determine whether many have simple enough APIs and good enough documentation to give it a try. Perhaps some of the code present here could be re-used, though I'd like to emphasize that this method is still a faster in terms of dev-time than implementing methods manually.
</p>
<p>To reiterate:
<ul>
  <li><a href="https://github.com/itsjoesullivan/digital-ocean-api-v2">JavaScript Digital Ocean API library</a>
  </li>
  <li>
    <a href="https://github.com/itsjoesullivan/digital-ocean-wrench">Digital Ocean Wrench (CLI)</a>
  </li>
  <li>
    <a href="https://github.com/itsjoesullivan/parsed-digital-ocean-api-documentation">Underlying parsed documentation</a>
  </li>
  <li>
    <a href="https://developers.digitalocean.com/documentation/v2">The documentation itself</a>
  </li>
</ul>
</p>
</div>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-31945659-1', 'auto');
ga('send', 'pageview');
</script>
<script src="https://use.typekit.net/vtn6mfd.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>
</body>
</html>
